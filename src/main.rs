use chrono::DateTime;
use chrono::Local;
use clap::Parser;
use env_logger::Builder;
use log::LevelFilter;
use log::debug;
use log::error;
use log::info;
use log::warn;
use std::fmt;
use std::fs;
use std::io;
use std::path::Path;
use std::path::PathBuf;
use thiserror::Error;

mod db;
mod engine;

pub const AUTHOR: &str = "Riko Naka";
pub const ABOUT: &str = "Rust translation and optimization of foremost tool";
pub const LONG_ABOUT: &str = "Snarfit is a console program to recover files based on their headers, footers, and internal data structures. This process is commonly referred to as data carving. Snarfit can work on image files, such as those generated by dd, Safeback, Encase, etc, or directly on a drive. The headers and footers can be specified by a configuration file or you can use command line switches to specify built-in file types. These built-in types look at the data structures of a given file format allowing for a more reliable and faster recovery.";
pub const DEFAULT_OUTPUT_DIRECTORY: &str = "snarfit_output";
pub const CHUNK_SIZE: usize = 512;
pub const DEFAULT_CONFIG_FILE: &str = "snarfit.conf";

pub enum Mode {
    None,
    Verbose,
    Quiet,
    Quick,
}

impl fmt::Display for Mode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Mode::None => write!(f, "none"),
            Mode::Verbose => write!(f, "verbose"),
            Mode::Quiet => write!(f, "quiet"),
            Mode::Quick => write!(f, "quick"),
        }
    }
}

#[derive(Parser, Debug)]
#[command(version, about=ABOUT, author=AUTHOR, long_about = None)]
struct Args {
    /// Specify input disk
    #[arg(short, long, default_value = "/dev/sda")]
    input: String,

    /// Set output directory
    #[arg(short, long, default_value = DEFAULT_OUTPUT_DIRECTORY)]
    output: String,

    /// Set configuration file to use
    #[arg(short, long, default_value = DEFAULT_CONFIG_FILE)]
    config: String,

    /// Specify file type (-t jpeg,pdf .etc)
    #[arg(short, long, default_value = "jpeg")]
    file_type: String,

    /// Set chunk size
    #[arg(long, default_value_t = CHUNK_SIZE)]
    chunk_size: usize,

    /// Quiet mode, suppress output messages
    #[arg(long, action)]
    quiet: bool,

    /// Quick mode. Search are performed on 512 byte boundaries
    #[arg(short, long, action)]
    quick: bool,

    /// Verbose mode, logs all messages to screen
    #[arg(short, long, action)]
    verbose: bool,
}

pub struct Config {
    pub mode: Mode,
    pub input: String,
    pub output: PathBuf,
    pub chunk_size: usize,
}

#[derive(Error, Debug)]
pub enum SnarfitError {
    #[error("io error")]
    IOError(#[from] io::Error),
}

fn init_output_dir(output: &str) -> Result<PathBuf, io::Error> {
    let path = Path::new(output);
    if !path.exists() {
        info!("create output directory [{}]", output);
        fs::create_dir_all(path)?;
    } else {
        warn!("output directory [{}] exist", output);
    }
    fs::canonicalize(output)
}

fn main() {
    let _ = Builder::new().filter(None, LevelFilter::Debug).init();

    let prog_name = env!("CARGO_PKG_NAME");
    let prog_version = env!("CARGO_PKG_VERSION");
    info!("{} {} is running", prog_name, prog_version);

    let args = Args::parse();

    let mode = if args.quick {
        Mode::Quick
    } else if args.quiet {
        Mode::Quiet
    } else if args.verbose {
        Mode::Verbose
    } else {
        Mode::None
    };
    info!("[{}] mode is enabled", &mode);

    let input = args.input;
    let output = match init_output_dir(&args.output) {
        Ok(o) => o,
        Err(e) => panic!("init the output directory failed: {}", e),
    };

    info!("set input disk [{}] done", &input);
    info!("set output directory [{}] done", &args.output);
    let config = Config {
        mode,
        input,
        output,
        chunk_size: args.chunk_size,
    };

    match engine::process_disk(config) {
        Ok(_) => (),
        Err(_) => (),
    };
}
